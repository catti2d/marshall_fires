knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(plyr)
library(sf)
library(raster)
library(rgdal)
library(ggplot2)
library(spacetime)
library(gridExtra)
library(stringr)
# PM2.5 package recommended by Priyanka
library(bjzresc)
# to make the spherical geometry errors go away
sf::sf_use_s2(FALSE)
## use bjzresc package to get list of purple air sensors; save to df instead of csv
pa_download = getPurpleairLst(output.path = NULL)
## Use marshall fire boundary to extract stations
marshall_fire = st_read("GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp")
## Use marshall fire boundary to extract stations
marshall_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp")
## Use marshall fire boundary to extract stations
(marshall_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
## Use marshall fire boundary to extract stations
wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp")
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
marshall_fire = wfgis_fire %>% filter(poly_Incid == "Marshall Wildfire")
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire")
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire"))
plor(marshall_fire)
plot(marshall_fire)
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire"))
plot(marshall_fire$poly_Acres)
prg = crs(marshall_fire,asText=TRUE)
prg
# remove null Lat/Long PA sensors -- important to creating spatial dataframe
pa_download = pa_download[complete.cases(pa_download[c("Lat","Lon")]),]
# check that it worked
sum(is.na(pa_download[c("Lat","Lon")]))
## Intersect municipal boundaries with PA sensors
# remove null Lat/Long PA sensors -- important to creating spatial dataframe
pa_download = pa_download[complete.cases(pa_download[c("Lat","Lon")]),]
# check that it worked
sum(is.na(pa_download[c("Lat","Lon")]))
# create spatial dataframe
pa_download_spatial = pa_download %>%
st_as_sf(coords = c("Lon","Lat")) %>%
st_set_crs(prg)
# check CRS
crs(pa_download_spatial)
# intersect PA download area and fire affected area to download sensors
fire_affected_sensors = st_intersection(pa_download_spatial,st_buffer(marshall_fire,0))
# get sensor IDs for sensors in fire affected area
fire_area_sensor_IDs = fire_affected_sensors$ID
# filter original dataframe to include only sensors in fire affected area
fire_area_sensors = pa_download[pa_download$ID %in% fire_area_sensor_IDs, ]
# preview data
fire_area_sensors
# preview data
fire_area_sensors
plot(fire_areas)
## Use boulder county shapefile to extract municipal boundaries for Louisville and Superior
BO_CO = st_read("Boulder_county_munis/Municipalities.shp")
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire"))
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire"))
plot(marshall_fire$geometry)
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
wfigs_fire %>% filter(poly_Incid == "Marshall Wildfire")
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
wfigs_fire %>% filter(poly_Incid == "Coleman Wildfire")
wfigs_fire
wfigs_fire$poly_Incid
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall"))
prg = crs(marshall_fire,asText=TRUE)
## Intersect municipal boundaries with PA sensors
# remove null Lat/Long PA sensors -- important to creating spatial dataframe
pa_download = pa_download[complete.cases(pa_download[c("Lat","Lon")]),]
# check that it worked
sum(is.na(pa_download[c("Lat","Lon")]))
# create spatial dataframe
pa_download_spatial = pa_download %>%
st_as_sf(coords = c("Lon","Lat")) %>%
st_set_crs(prg)
# check CRS
crs(pa_download_spatial)
# intersect PA download area and fire affected area to download sensors
fire_affected_sensors = st_intersection(pa_download_spatial,st_buffer(marshall_fire,0))
# get sensor IDs for sensors in fire affected area
fire_area_sensor_IDs = fire_affected_sensors$ID
# filter original dataframe to include only sensors in fire affected area
fire_area_sensors = pa_download[pa_download$ID %in% fire_area_sensor_IDs, ]
# preview data
fire_area_sensors
## Use marshall fire boundary to extract stations
(wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp"))
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall"))
prg = crs(marshall_fire,asText=TRUE)
## Intersect municipal boundaries with PA sensors
# remove null Lat/Long PA sensors -- important to creating spatial dataframe
pa_download = pa_download[complete.cases(pa_download[c("Lat","Lon")]),]
# check that it worked
sum(is.na(pa_download[c("Lat","Lon")]))
# create spatial dataframe
pa_download_spatial = pa_download %>%
st_as_sf(coords = c("Lon","Lat")) %>%
st_set_crs(prg)
# check CRS
crs(pa_download_spatial)
# intersect PA download area and fire affected area to download sensors
fire_affected_sensors = st_intersection(pa_download_spatial,st_buffer(marshall_fire,0))
# get sensor IDs for sensors in fire affected area
fire_area_sensor_IDs = fire_affected_sensors$ID
# filter original dataframe to include only sensors in fire affected area
fire_area_sensors = pa_download[pa_download$ID %in% fire_area_sensor_IDs, ]
# preview data
fire_area_sensors
## plot sensors within fire affected areas
# basemap = Superior and Louisville muni limits
basemap = ggplot(data=fire_areas) +
geom_sf()
## plot sensors within fire affected areas
# basemap = Superior and Louisville muni limits
basemap = ggplot(data=marshall_fire) +
geom_sf()
# add on stations
sensor_map = basemap + geom_point(data=fire_area_sensors,aes(x=Lon,y=Lat))
# show map
sensor_map
## Use boulder county shapefile to extract municipal boundaries for Louisville and Superior
BO_CO = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/Boulder_county_munis/Municipalities.shp")
superior_louisville = BO_CO %>% filter(ZONEDESC == "Louisville" |ZONEDESC == "Superior")
# creates variable for the projection of the BOCO shapefiles
prg = crs(fire_areas,asText=TRUE)
# creates variable for the projection of the BOCO shapefiles
prg = crs(superior_louisville,asText=TRUE)
prg
superior_louisville = BO_CO %>% filter(ZONEDESC == "Louisville" |ZONEDESC == "Superior") %>% set_crs(prg)
# creates variable for the projection of the BOCO shapefiles
crs(superior_louisville,asText=TRUE)
basemap_counties = basemap + ggplot(data = superior_louisville)
basemap_counties = basemap + ggplot_add(data = superior_louisville)
basemap_counties = basemap + geom_polygon(data = superior_louisville)
(basemap_counties = basemap + geom_polygon(data = superior_louisville))
(basemap_counties = basemap + geom_polygon(data = superior_louisville, aes(x=Long,y=Lat)))
(basemap_counties = basemap + geom_polygon(data = superior_louisville, aes(x=Lon,y=Lat)))
(superior_louisville = BO_CO %>% filter(ZONEDESC == "Louisville" |ZONEDESC == "Superior"))
# basemap = Superior and Louisville muni limits
basemap = ggplot(data=superior_louisville) +
geom_sf()
# basemap = Superior and Louisville muni limits
(basemap = ggplot(data=superior_louisville) +
geom_sf())
# add on stations
sensor_map = basemap + geom_point(data=fire_area_sensors,aes(x=Lon,y=Lat))
# show map
sensor_map
# same as marshall fire
prg = crs(superior_louisville,asText=TRUE)
## Intersect municipal boundaries with PA sensors
# remove null Lat/Long PA sensors -- important to creating spatial dataframe
pa_download = pa_download[complete.cases(pa_download[c("Lat","Lon")]),]
# check that it worked
sum(is.na(pa_download[c("Lat","Lon")]))
# create spatial dataframe
pa_download_spatial = pa_download %>%
st_as_sf(coords = c("Lon","Lat")) %>%
st_set_crs(prg)
# check CRS
crs(pa_download_spatial)
# intersect PA download area and fire affected area to download sensors
fire_affected_sensors = st_intersection(pa_download_spatial,st_buffer(superior_louisville,0))
# get sensor IDs for sensors in fire affected area
fire_area_sensor_IDs = fire_affected_sensors$ID
# filter original dataframe to include only sensors in fire affected area
fire_area_sensors = pa_download[pa_download$ID %in% fire_area_sensor_IDs, ]
# preview data
fire_area_sensors
# basemap = Superior and Louisville muni limits
(basemap = ggplot(data=marshall_fire) +
geom_sf())
# add on stations
sensor_map = basemap + geom_point(data=fire_area_sensors,aes(x=Lon,y=Lat))
# show map
sensor_map
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(plyr)
library(sf)
library(raster)
library(rgdal)
library(ggplot2)
library(spacetime)
library(gridExtra)
library(stringr)
library(leaflet)
# PM2.5 package recommended by Priyanka
library(bjzresc)
# to make the spherical geometry errors go away
sf::sf_use_s2(FALSE)
## Use marshall fire boundary to extract stations
wfigs_fire = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/WFIGS_-_Wildland_Fire_Perimeters_Full_History/FH_Perimeter.shp")
(marshall_fire = wfigs_fire %>% filter(poly_Incid == "Marshall"))
(prg = crs(marshall_fire,asText=TRUE))
## Read in destroyed home and building sites
destroyed_homes = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/output_damage_files/destroyed_homes.shp")
damaged_homes = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/output_damage_files/damaged_homes.shp")
destroyed_businesses = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/output_damage_files/destroyed_businesses.shp")
damaged_businesses = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/output_damage_files/damaged_businesses.shp")
# check that crs matches leaflet
(crs(destroyed_homes))
# mutate type and select columns needed
(destroyed_homes = destroyed_homes %>% mutate(type = "destroyed - residential") %>% dplyr::rename(jurisdiction = JURISDICTI) %>% dplyr::select(jurisdiction, type, latlong, geometry))
(destroyed_businesses = destroyed_businesses  %>% mutate(type = "destroyed - non-residential") %>% dplyr::rename(jurisdiction = Jurisdicti) %>% dplyr::select(jurisdiction, type, latlong, geometry))
(damaged_homes = damaged_homes %>% mutate(type = "damaged - residential") %>% dplyr::rename(jurisdiction = JURISDICTI) %>% dplyr::select(jurisdiction, type, latlong, geometry))
(damaged_business = damaged_businesses %>% mutate(type = "damaged - non-residential") %>% dplyr::rename(jurisdiction = Jurisdicti) %>% dplyr::select(jurisdiction, type, latlong, geometry))
# combine into one df, using the "," indicator keeps decimal points
(destroyed_damaged =rbind(destroyed_homes,destroyed_businesses,damaged_homes,damaged_business) %>% separate(latlong, c("lat","long"), ",", convert = FALSE))
# change lat and long to floats
destroyed_damaged$lat = as.double(destroyed_damaged$lat)
destroyed_damaged$long = as.double(destroyed_damaged$long)
AQ_df = rbind(AQ_df, AQ_df2)
## Read downloaded PA files from their filepath and turn them into a DF
# directory where files are stored
dir = "superior_lousiville_PAs/"
dir2 = "marshall_fire_path_PAs/"
# create a list of all file names in this directory
file_name1 = list.files(path=dir, pattern="*.csv", full.names=TRUE)
file_names2 = list.files(path=dir2, pattern="*.csv", full.names=TRUE)
# read csvs for each filename in list --> results in a list of lists
AQ_files = lapply(file_name1, read_csv)
AQ_files2 = lapply(file_names2, read_csv)
# fewer than above because A and B sensors come in separately
#length(AQ_files)
## Combine lists of sensor data into a single dataframe
# combine AQ lists into single AQ dataframe
(AQ_df = rbind.fill(AQ_files1) %>% as.data.frame())
## Read downloaded PA files from their filepath and turn them into a DF
# directory where files are stored
dir = "superior_lousiville_PAs/"
dir2 = "marshall_fire_path_PAs/"
# create a list of all file names in this directory
file_name1 = list.files(path=dir, pattern="*.csv", full.names=TRUE)
file_names2 = list.files(path=dir2, pattern="*.csv", full.names=TRUE)
# read csvs for each filename in list --> results in a list of lists
AQ_files1 = lapply(file_name1, read_csv)
AQ_files2 = lapply(file_names2, read_csv)
# fewer than above because A and B sensors come in separately
#length(AQ_files)
## Combine lists of sensor data into a single dataframe
# combine AQ lists into single AQ dataframe
(AQ_df = rbind.fill(AQ_files1) %>% as.data.frame())
(AQ_df2 = rbind.fill(AQ_files2) %>% as.data.frame())
AQ_df = rbind(AQ_df, AQ_df2)
## Clean data
# create a date column in POSIX format to create time series
AQ_df$datetime = as.POSIXct(AQ_df$created_at)
# rename and select important columns
AQ_df = AQ_df %>%
dplyr::rename(pm25_a = `PM2.5_CF_1_ug/m3_A`,
pm25_b = `PM2.5_CF_1_ug/m3_B`,
temp = Temperature_F_A,
rh = `Humidity_%_A`)
# create hourly pm colum
AQ_df$hour = as.POSIXlt(AQ_df$datetime)$hour
# Convert numeric values to a numeric class
AQ_df$pm25_a = as.numeric(AQ_df$pm25_a)
AQ_df$pm25_b = as.numeric(AQ_df$pm25_b)
AQ_df$temp = as.numeric(AQ_df$temp)
AQ_df$rh = as.numeric(AQ_df$rh)
# create hourly versions of temperature, pm, and rh
AQ_df_hr = AQ_df %>%
group_by(ID, hour) %>%
summarise(hourly_pm=mean(pm25_a),hourly_temp=mean(temp),hourly_rh=mean(rh))
# create a key coordinating the sensor ID number to its lat/lon
id_key <- AQ_df %>%
group_by(ID) %>%
dplyr::select(ID, Lon, Lat, Name, Location) %>%
unique()
# select columns that I need for each spacetime object
AQ_df = AQ_df %>%
dplyr::select(ID, datetime, pm25_a, pm25_b, temp, rh, Lon, Lat, Location) %>% as.data.frame()
# AQ_df_hr = AQ_df %>%
#   dplyr::select(ID, hour, datetime, hourly_pm, hourly_temp, hourly_rh, Lon, Lat) %>% as.data.frame()
# prepare data for fire period mapping
# dataframe with fire period stats
(time_period_classification = AQ_df %>%
dplyr::select(ID, Lon, Lat, Location, datetime, pm25_a, pm25_b, temp, rh) %>%
group_by(ID) %>%
# add in NAs to timeseries to calculate % complete (before missing time periods were just absent and not NAs in the dataset)
complete(datetime = seq(min(datetime), max(datetime), by = "10 min")) %>%
mutate(time_period = ifelse(datetime<as.POSIXct(strptime("2021-12-30 10:00:00", "%Y-%m-%d %H:%M:%S")), "pre_fire_period",
ifelse(datetime>=as.POSIXct(strptime("2021-12-30 10:00:00", "%Y-%m-%d %H:%M:%S")) & datetime<= as.POSIXct(strptime("2022-01-01 11:59:59", "%Y-%m-%d %H:%M:%S")), "fire_period",
ifelse(datetime>as.POSIXct(strptime("2022-01-01 11:59:59", "%Y-%m-%d %H:%M:%S")), "post_fire_period", "other time")))) %>%
group_by(ID,time_period) %>%
dplyr::summarize(
complete_a= sum(complete.cases(pm25_a))/n()*100
#complete_b = sum(complete.cases(pm25_b))/n()*100
) %>%
pivot_wider(names_from = time_period, values_from = complete_a) %>%
rowwise() %>%
mutate(Status = case_when(
fire_period >= 75 & post_fire_period >= 85 & pre_fire_period >= 95 ~ "Complete data throughout fire period",
fire_period < 75 & post_fire_period >= 75 & pre_fire_period >= 95 ~ "Sensor offline during fire, returned online",
fire_period < 75 & post_fire_period <= 75 & pre_fire_period >= 95 ~ "Sensor offline during fire, did not return online",
fire_period < 75 & post_fire_period <= 75 & is.na(pre_fire_period) ~ "Sensor added during fire, did not return online",
fire_period < 75 & post_fire_period >= 75 & is.na(pre_fire_period) ~ "Sensor added during fire, returned online",
is.na(fire_period) & is.na(pre_fire_period) ~ "Sensor came online after fire"
))
)
time_period_classification$Status = factor(time_period_classification$Status, levels = c("Complete data throughout fire period", "Sensor offline during fire, returned online", "Sensor offline during fire, did not return online", "Sensor added during fire, returned online", "Sensor added during fire, did not return online", "Sensor came online after fire"))
# Create time period variable based on availability during fire, inside/outside status for mapping
(plot_data = AQ_df %>%
group_by(ID) %>%
dplyr::select(ID, Lon, Lat, Location) %>%
# use location[1] presuming indoor/outdoor doesn't change
dplyr::summarize(Location = Location[1],
Lat = Lat[1],
Lon = Lon[1]))
# merge fire stats and plot data
(plot_data = merge(plot_data, time_period_classification, by = "ID", all=TRUE))
(month_added_plot = AQ_df %>%
group_by(ID) %>%
dplyr::select(ID, Lon, Lat, Location, datetime) %>%
# use location[1] presuming indoor/outdoor doesn't change
dplyr::summarize(Location = Location[1],
Lat = Lat[1],
Lon = Lon[1],
Month = ifelse(format(datetime[1], "%m-%Y") == "12-2021","Before or during 12-2021",format(datetime[1], "%m-%Y"))))
month_added_plot$Month = factor(month_added_plot$Month, levels = c("Before or during 12-2021","01-2022","02-2022"))
(month_added_plot = AQ_df %>%
group_by(ID) %>%
dplyr::select(ID, Lon, Lat, Location, datetime) %>%
# use location[1] presuming indoor/outdoor doesn't change
dplyr::summarize(Location = Location[1],
Lat = Lat[1],
Lon = Lon[1],
Month = ifelse(format(datetime[1], "%m-%Y") == "12-2021","Before or during 12-2021",format(datetime[1], "%m-%Y"))))
month_added_plot$Month = factor(month_added_plot$Month, levels = c("Before or during 12-2021","01-2022","02-2022","03-2022"))
## Some summary stats
AQ_df %>% group_by(ID) %>% dplyr::summarise(count_A_na = sum(is.na(pm25_a)),
count_B_na = sum(is.na(pm25_b)),
pct_A_na = (count_A_na/length(pm25_a))*100,
pct_B_na = (count_B_na/length(pm25_b))*100)
plot_data %>% group_by(Status) %>% dplyr::summarise(n = n())
# set factors to false
options(stringsAsFactors = FALSE)
# create pallete for destroyed and damaged building colors
pal = colorFactor(c("red","orange","magenta","light pink"), domain = unique(destroyed_damaged$type))
## create indoor/outdoor icons
sensorIcon = awesomeIconList(
"inside" = makeAwesomeIcon(
icon = "home",
iconColor = "white",
markerColor = "blue",
library = "fa"
),
"outside" = makeAwesomeIcon(
icon = "tree",
iconColor = "white",
markerColor = "green",
library = "fa"
))
# map
(fire_destruction_and_AQ_plot = leaflet(plot_data) %>%
addTiles() %>%
addAwesomeMarkers(icon = ~sensorIcon[Location],
lng = plot_data$Lon, lat = plot_data$Lat) %>%
addCircleMarkers(color = ~pal(destroyed_damaged$type),
radius = 3.5,
opacity = 1,
lng = destroyed_damaged$long, lat = destroyed_damaged$lat) %>%
addLegend("topright", pal = pal, values = ~destroyed_damaged$type,
title = "Fire damage"))
## plot sensors within fire affected areas
ggplot() +
geom_path(data = BOCO_roads_df, aes(x = ))
# basemap = Superior and Louisville muni limits
(basemap = ggplot(data=superior_louisville) +
geom_sf())
## Use boulder county shapefile to extract municipal boundaries for Louisville and Superior
BO_CO = st_read("/Users/esrieves/Documents/GitHub/marshall_fires/GIS_inputs_destruction_fireboundary/Boulder_county_munis/Municipalities.shp")
(superior_louisville = BO_CO %>% filter(ZONEDESC == "Louisville" |ZONEDESC == "Superior"))
# same as marshall fire
(crs(superior_louisville,asText=TRUE))
## create indoor/outdoor icons
sensorIcon = awesomeIconList(
"inside" | "outside" = makeAwesomeIcon(
